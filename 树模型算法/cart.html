<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CART树 - 决策树基础</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
</head>
<body>
    <div class="detail-page">
        <a href="index.html" class="back-button">← 返回主页</a>

        <div class="algorithm-header">
            <h1>🌲 CART树</h1>
            <span class="tag">基础起点</span>
        </div>

        <div class="content-section">
            <h2>📚 什么是CART树？</h2>
            <p>CART（Classification and Regression Trees）是决策树的基础算法，1984年提出。它是单棵回归或分类树，使用Gini系数（分类）或方差（回归）来进行特征分裂。</p>
            
            <div class="image-container">
                <img src="images/cartTree.png" alt="CART树结构">
            </div>
        </div>

        <div class="content-section">
            <h2>🔑 核心特点</h2>
            <ul style="line-height: 2; color: #555; list-style: none; padding-left: 0;">
                <li><strong>分裂标准：</strong>Gini不纯度（分类）或最小方差（回归）</li>
                <li><strong>结构：</strong>二叉树结构，每个节点最多有两个子节点</li>
                <li><strong>简单易懂：</strong>决策过程清晰，可解释性强</li>
                <li><strong>易过拟合：</strong>没有集成机制，容易记住训练数据</li>
            </ul>
        </div>

        <div class="tip-box">
            <strong>💡 通俗理解：</strong>就像一个人做决策，根据一个特征问"是或否"，然后继续问下一个问题，直到得出结论。但是一个人可能太死板，容易记住所有训练过的例子。
        </div>

        <div class="content-section">
            <h2>⚙️ 分裂过程</h2>
            <div class="interactive-demo">
                <p style="margin-bottom: 15px;">点击按钮查看分裂过程：</p>
                <button class="demo-button" onclick="showSplitDemo()">演示Gini分裂</button>
                <div id="split-result" style="margin-top: 20px; padding: 15px; background: white; border-radius: 6px; display: none;"></div>
            </div>
        </div>

        <div class="content-section">
            <h2>⚠️ 局限性</h2>
            <p><strong>容易过拟合：</strong>单棵树会学习训练数据的细节，包括噪声，导致在测试集上表现差。这是所有后续算法要解决的问题。</p>
        </div>
    </div>

    <script>
        function showSplitDemo() {
            const result = document.getElementById('split-result');
            result.style.display = 'block';
            // 使用字符串拼接避免模板字符串中$符号的问题
            result.innerHTML = 
                '<h3 style="color: #27ae60; margin-bottom: 10px;">Gini分裂示例</h3>' +
                '<p>假设有10个样本，5个类别A，5个类别B</p>' +
                '<p><strong>Gini系数公式：</strong> \\(\\text{Gini} = 1 - \\sum_{i=1}^{c} p_i^2\\)</p>' +
                '<p><strong>计算：</strong> \\(\\text{Gini} = 1 - \\left(\\frac{5}{10}\\right)^2 - \\left(\\frac{5}{10}\\right)^2 = 0.5\\)</p>' +
                '<p style="margin-top: 10px;">选择一个特征分裂后，如果左右子节点Gini更小，就采用这个分裂点。</p>';
            
            // 等待MathJax加载完成后再渲染
            function renderMathJax() {
                if (window.MathJax && MathJax.typesetPromise) {
                    MathJax.typesetPromise([result]).catch(function(err) {
                        console.log('MathJax渲染错误:', err);
                    });
                } else if (window.MathJax && MathJax.startup) {
                    // 如果MathJax还在加载，等待它完成
                    MathJax.startup.promise.then(function() {
                        if (MathJax.typesetPromise) {
                            MathJax.typesetPromise([result]).catch(function(err) {
                                console.log('MathJax渲染错误:', err);
                            });
                        }
                    });
                } else {
                    // MathJax还没加载，等待一下再试
                    setTimeout(renderMathJax, 200);
                }
            }
            setTimeout(renderMathJax, 50);
        }
    </script>
</body>
</html>

